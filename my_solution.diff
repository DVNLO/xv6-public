diff --git a/Makefile b/Makefile
index 09d790c..6bfedf2 100644
--- a/Makefile
+++ b/Makefile
@@ -76,7 +76,7 @@ AS = $(TOOLPREFIX)gas
 LD = $(TOOLPREFIX)ld
 OBJCOPY = $(TOOLPREFIX)objcopy
 OBJDUMP = $(TOOLPREFIX)objdump
-CFLAGS = -fno-pic -static -fno-builtin -fno-strict-aliasing -O2 -Wall -MD -ggdb -m32 -Werror -fno-omit-frame-pointer
+CFLAGS = -fno-pic -static -fno-builtin -fno-strict-aliasing -O1 -Wall -MD -ggdb -m32 -Werror -fno-omit-frame-pointer -gdwarf-2
 CFLAGS += $(shell $(CC) -fno-stack-protector -E -x c /dev/null >/dev/null 2>&1 && echo -fno-stack-protector)
 ASFLAGS = -m32 -gdwarf-2 -Wa,-divide
 # FreeBSD ld wants ``elf_i386_fbsd''
@@ -181,6 +181,7 @@ UPROGS=\
 	_usertests\
 	_wc\
 	_zombie\
+        _lab2\
 
 fs.img: mkfs README $(UPROGS)
 	./mkfs fs.img README $(UPROGS)
@@ -217,7 +218,7 @@ QEMUGDB = $(shell if $(QEMU) -help | grep -q '^-gdb'; \
 	then echo "-gdb tcp::$(GDBPORT)"; \
 	else echo "-s -p $(GDBPORT)"; fi)
 ifndef CPUS
-CPUS := 2
+CPUS := 1
 endif
 QEMUOPTS = -drive file=fs.img,index=1,media=disk,format=raw -drive file=xv6.img,index=0,media=disk,format=raw -smp $(CPUS) -m 512 $(QEMUEXTRA)
 
diff --git a/defs.h b/defs.h
index 82fb982..7a628d9 100644
--- a/defs.h
+++ b/defs.h
@@ -120,6 +120,7 @@ void            userinit(void);
 int             wait(void);
 void            wakeup(void*);
 void            yield(void);
+int             setpriority(int);
 
 // swtch.S
 void            swtch(struct context**, struct context*);
diff --git a/lab2.c b/lab2.c
new file mode 100644
index 0000000..984399b
--- /dev/null
+++ b/lab2.c
@@ -0,0 +1,101 @@
+#include "types.h"
+#include "user.h"
+
+
+void test_priority_aging()
+{
+  printf(1, "test_priority_aging()\n");
+  int pid1 = fork();
+  if(!pid1)
+  {
+    int pid2 = fork();
+    int priority_val = 0;
+    if(!pid2)
+    {
+      setpriority(priority_val);
+      printf(1, "child 2 completes\n");
+    }
+    else if(pid2 > 0)
+    {
+      setpriority(priority_val);
+      int volatile i = 0;
+      while(i >= 0)
+        ++i;
+      printf(1, "child 1 completes\n");
+      wait();
+    }
+    else
+    {
+      printf(2, "Error\n");
+    }
+  }
+  else if(pid1 > 0)
+  {
+    wait();
+    wait();
+    printf(1, "parent completes\n");
+  }
+  else
+  {
+    printf(2, "Error\n");
+  }
+}
+
+int main(int argc, char *argv[])
+{
+  void PScheduler(void);
+  printf(1, "\n This program tests the correctness of your lab#2\n");
+  PScheduler();
+  test_priority_aging();
+  exit();
+  return 0;
+}
+  
+    
+void PScheduler(void)
+{
+    // use this part to test the priority scheduler. Assuming that the priorities range between range between 0 to 31
+    // 0 is the highest priority and 31 is the lowest priority.  
+  int pid;
+  int i,j,k;
+  printf(1, "\n  Step 2: testing the priority scheduler and setpriority(int priority)) systema call:\n");
+  printf(1, "\n  Step 2: Assuming that the priorities range between range between 0 to 31\n");
+  printf(1, "\n  Step 2: 0 is the highest priority. All processes have a default priority of 10\n");
+  printf(1, "\n  Step 2: The parent processes will switch to priority 0\n");
+  setpriority(0);
+  //printf(1, "ret == %d\n", ret);
+  for (i = 0; i <  3; i++) 
+  {
+    pid = fork();
+    if(pid > 0) 
+    {
+      continue;
+    }
+    else if(pid == 0) 
+    {
+      setpriority(30-10*i);
+      //printf(1, "ret == %d\n", ret);
+      for(j = 0; j < 500000; j++) 
+      {
+        for(k = 0; k < 1000; k++) 
+        {
+	  asm("nop"); 
+        }
+      }
+      printf(1, "\n child# %d with priority %d has finished! \n",getpid(),30-10*i);		
+      exit();
+    }
+    else 
+    {
+      printf(2," \n Error \n");
+    }
+  }
+  if(pid > 0) 
+  {
+    for (i = 0; i <  3; i++) 
+    {
+      wait();
+    }
+    printf(1,"\n if processes with highest priority finished first then its correct \n");
+  }
+}
diff --git a/proc.c b/proc.c
index 806b1b1..22f9046 100644
--- a/proc.c
+++ b/proc.c
@@ -88,6 +88,7 @@ allocproc(void)
 found:
   p->state = EMBRYO;
   p->pid = nextpid++;
+  p->priority = 10;
 
   release(&ptable.lock);
 
@@ -277,6 +278,7 @@ wait(void)
   struct proc *curproc = myproc();
   
   acquire(&ptable.lock);
+  --curproc->priority;	// increase priority waiting process 
   for(;;){
     // Scan through table looking for exited children.
     havekids = 0;
@@ -311,6 +313,37 @@ wait(void)
   }
 }
 
+int
+setpriority(int priority_value)
+{
+  struct proc * p = myproc();
+  acquire(&ptable.lock);
+  int rc = p->priority = priority_value;
+  release(&ptable.lock);
+  return rc;
+}
+
+inline
+void
+switch_to_selected_process(struct proc * p, struct cpu * c)
+{
+  // Switch to chosen process.  It is the process's job
+  // to release ptable.lock and then reacquire it
+  // before jumping back to us.
+  c->proc = p;
+  switchuvm(p);
+   
+  p->state = RUNNING;
+  ++p->priority;  // Decrease priority of a run process.
+ 
+  swtch(&(c->scheduler), p->context);
+  switchkvm();
+
+  // Process is done running for now.
+  // It should have changed its p->state before coming back.
+  c->proc = 0;
+}
+
 //PAGEBREAK: 42
 // Per-CPU process scheduler.
 // Each CPU calls scheduler() after setting itself up.
@@ -330,28 +363,31 @@ scheduler(void)
     // Enable interrupts on this processor.
     sti();
 
-    // Loop over process table looking for process to run.
     acquire(&ptable.lock);
-    for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
-      if(p->state != RUNNABLE)
-        continue;
-
-      // Switch to chosen process.  It is the process's job
-      // to release ptable.lock and then reacquire it
-      // before jumping back to us.
-      c->proc = p;
-      switchuvm(p);
-      p->state = RUNNING;
-
-      swtch(&(c->scheduler), p->context);
-      switchkvm();
-
-      // Process is done running for now.
-      // It should have changed its p->state before coming back.
-      c->proc = 0;
+    struct proc * next_p = ptable.proc;
+    // Search for the first RUNNABLE process
+    while(next_p < &ptable.proc[NPROC]
+          && next_p->state != RUNNABLE)
+    {
+      ++next_p;
+    }
+    // Search for a higher priority RUNNABLE process
+    p = next_p + 1;
+    while(p < &ptable.proc[NPROC])
+    {
+      if(p->state == RUNNABLE 
+         && p->priority < next_p->priority)
+      {
+        next_p = p;
+      }
+      ++p;
+    }
+    if(next_p >= ptable.proc 
+       && next_p < &ptable.proc[NPROC])
+    {
+      switch_to_selected_process(next_p, c);
     }
     release(&ptable.lock);
-
   }
 }
 
diff --git a/proc.h b/proc.h
index 1647114..640f747 100644
--- a/proc.h
+++ b/proc.h
@@ -49,6 +49,7 @@ struct proc {
   struct file *ofile[NOFILE];  // Open files
   struct inode *cwd;           // Current directory
   char name[16];               // Process name (debugging)
+  int priority;                // Process priority
 };
 
 // Process memory is laid out contiguously, low addresses first:
diff --git a/syscall.c b/syscall.c
index ee85261..418a82c 100644
--- a/syscall.c
+++ b/syscall.c
@@ -103,6 +103,7 @@ extern int sys_unlink(void);
 extern int sys_wait(void);
 extern int sys_write(void);
 extern int sys_uptime(void);
+extern int sys_setpriority(void);
 
 static int (*syscalls[])(void) = {
 [SYS_fork]    sys_fork,
@@ -126,6 +127,7 @@ static int (*syscalls[])(void) = {
 [SYS_link]    sys_link,
 [SYS_mkdir]   sys_mkdir,
 [SYS_close]   sys_close,
+[SYS_setpriority] sys_setpriority,
 };
 
 void
diff --git a/syscall.h b/syscall.h
index bc5f356..86390e7 100644
--- a/syscall.h
+++ b/syscall.h
@@ -20,3 +20,4 @@
 #define SYS_link   19
 #define SYS_mkdir  20
 #define SYS_close  21
+#define SYS_setpriority 22
diff --git a/sysproc.c b/sysproc.c
index 0686d29..a75452b 100644
--- a/sysproc.c
+++ b/sysproc.c
@@ -89,3 +89,20 @@ sys_uptime(void)
   release(&tickslock);
   return xticks;
 }
+
+int 
+sys_setpriority(void)
+{
+  int priority_value;
+  int rc = argint(0, &priority_value);
+  if(rc < 0
+     || priority_value < 0
+     || priority_value > 31)
+  {
+    return -1;
+  }
+  else
+  {
+    return setpriority(priority_value);
+  }
+}
diff --git a/user.h b/user.h
index 4f99c52..7d84e01 100644
--- a/user.h
+++ b/user.h
@@ -23,6 +23,7 @@ int getpid(void);
 char* sbrk(int);
 int sleep(int);
 int uptime(void);
+int setpriority(int);
 
 // ulib.c
 int stat(const char*, struct stat*);
diff --git a/usys.S b/usys.S
index 8bfd8a1..9ce48da 100644
--- a/usys.S
+++ b/usys.S
@@ -29,3 +29,4 @@ SYSCALL(getpid)
 SYSCALL(sbrk)
 SYSCALL(sleep)
 SYSCALL(uptime)
+SYSCALL(setpriority)
